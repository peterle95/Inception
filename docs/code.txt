=== ./Makefile ===
NAME = inception

all: build up

build: # build containers
	@echo "Building containers..."
	mkdir -p /home/pmolzer/data/mariadb
	mkdir -p /home/pmolzer/data/wordpress
	docker compose -f srcs/docker-compose.yml build

rebuild: # complete rebuild from scratch
	@echo "Rebuilding from scratch..."
	docker compose -f srcs/docker-compose.yml build --no-cache

up: # start containers
	@echo "Starting containers..."
	docker compose -f srcs/docker-compose.yml up -d

down: # stop containers
	@echo "Stopping containers..."
	docker compose -f srcs/docker-compose.yml down

clean: down # clean system
	@echo "Cleaning system..."
	docker system prune -af

fclean: clean # fully clean system
	@echo "Fully cleaning system..."
	docker run --rm -v /home/pmolzer/data:/data alpine rm -rf /data/mariadb /data/wordpress
	docker volume rm srcs_mariadb srcs_wordpress || true

re: fclean all # rebuild from scratch
	@echo "Rebuilding from scratch..."
	docker compose -f srcs/docker-compose.yml build --no-cache
	@echo "Starting containers..."
	docker compose -f srcs/docker-compose.yml up -d

.PHONY: all build up down clean fclean re
=== ./docs/things_to_do.txt ===
1. Check that the configurations files for nginx and wordpress are correct
--> https://medium.com/@ssterdev/inception-guide-42-project-part-i-7e3af15eb671

Next step will be to configure nginx and php so that they can communicate.
We would need to copy the default server configuration file from the nginx container and the default config for the php service and make some minor modifications to it.

Default config for PHP location: /etc/php/8.2/fpm/pool.d/www.conf
Default config for NGINX location: /etc/nginx/sites-available/default
While still having our containers running, we can open another terminal and copy these files from inside our containers using the command docker cp.

docker cp wp-php:/etc/php/8.2/fpm/pool.d/www.conf ./requirements/wordpress/.
docker cp nginx:/etc/nginx/sites-available/default ./requirements/nginx/.

For the php default configuration file “www.conf” we only need to change a 
single line (line 41). Instead of listening to the default “/run/php/php8.2-fpm.sock address,
 we need to tell php that it needs to accept FastCGI request from address “wp-php:9000”, 
 the localhost of our wordpress-php container at port 9000.

 2. Check also that the mariadb conf file is fine
-> https://medium.com/@ssterdev/inception-42-project-part-ii-19a06962cf3b

3. Custom website not generic website, change the script to display a basic webpage

4. Check how to test database

5.4. mariaDB check
Open another terminal and keep the terminal with the compose running. On this other terminal, run the following command to enter in the mariadb container.

docker exec -it mariadb /bin/bash
Then run the command to enter in the mysql

mysql -u your_user -p db_name 
Then run the command to see the tables

SHOW TABLES;
If you see the tables, it means that all is ok. If you want to see the database, run the following command:

SELECT * FROM table_name\G;
And if you want to delete a row in a table, run the following command:

DELETE FROM table_name WHERE column_name = some_value;
After that, you can exit the mysql and the container and all your project work is done. Congratulations!
=== ./docs/subject.txt ===
Mandatory part
This project involves setting up a small infrastructure composed of different services un￾der specific rules. The whole project has to be done in a virtual machine. You must use
Docker Compose.
Each Docker image must have the same name as its corresponding service.
Each service has to run in a dedicated container.
For performance reasons, the containers must be built from either the penultimate stable
version of Alpine or Debian. The choice is yours.
You also have to write your own Dockerfiles, one per service. The Dockerfiles must
be called in your docker-compose.yml by your Makefile.
This means you must build the Docker images for your project yourself. It is then forbid￾den to pull ready-made Docker images or use services such as DockerHub (Alpine/Debian
being excluded from this rule).
You then have to set up:
• A Docker container that contains NGINX with TLSv1.2 or TLSv1.3 only.
• A Docker container that contains WordPress with php-fpm (it must be installed
and configured) only, without nginx.
• A Docker container that contains only MariaDB, without nginx.
• A volume that contains your WordPress database.
• A second volume that contains your WordPress website files.
• A docker-network that establishes the connection between your containers.
Your containers must restart automatically in case of a crash.

A Docker container is not a virtual machine. Thus, it is not
recommended to use any hacky patches based on ’tail -f’ and similar
methods when trying to run it. Read about how daemons work and
whether it’s a good idea to use them or not.

Of course, using network: host or --link or links: is forbidden.
The network line must be present in your docker-compose.yml file.
Your containers must not be started with a command running an
infinite loop. Thus, this also applies to any command used as
entrypoint, or used in entrypoint scripts. The following are a
few prohibited hacky patches: tail -f, bash, sleep infinity, while
true.
Read about PID 1 and the best practices for writing Dockerfiles.
• In your WordPress database, there must be two users, one of them being the admin￾istrator. The administrator’s username must not contain ’admin’, ’Admin’, ’admin￾istrator’, or ’Administrator’ (e.g., admin, administrator, Administrator, admin-123,
etc.).
Your volumes will be available in the /home/login/data folder of the
host machine using Docker. Of course, you have to replace the login
with yours.
To simplify the process, you must configure your domain name to point to your local
IP address.
This domain name must be login.42.fr. Again, you must use your own login.
For example, if your login is ’wil’, wil.42.fr will redirect to the IP address pointing to
Wil’s website.
The latest tag is prohibited.
Passwords must not be present in your Dockerfiles.
The use of environment variables is mandatory.
It is also strongly recommended to use a .env file to store
environment variables and to use the Docker secrets to store any
confidential information.
Your NGINX container must be the sole entry point into your
infrastructure, accessible only via port 443, using the TLSv1.2
or TLSv1.3 protocol.

Below is an example of the expected directory structure:
$> ls -alR
total XX
drwxrwxr-x 3 wil wil 4096 avril 42 20:42 .
drwxrwxrwt 17 wil wil 4096 avril 42 20:42 ..
-rw-rw-r-- 1 wil wil XXXX avril 42 20:42 Makefile
drwxrwxr-x 3 wil wil 4096 avril 42 20:42 secrets
drwxrwxr-x 3 wil wil 4096 avril 42 20:42 srcs
./secrets:
total XX
drwxrwxr-x 2 wil wil 4096 avril 42 20:42 .
drwxrwxr-x 6 wil wil 4096 avril 42 20:42 ..
-rw-r--r-- 1 wil wil XXXX avril 42 20:42 credentials.txt
-rw-r--r-- 1 wil wil XXXX avril 42 20:42 db_password.txt
-rw-r--r-- 1 wil wil XXXX avril 42 20:42 db_root_password.txt
./srcs:
total XX
drwxrwxr-x 3 wil wil 4096 avril 42 20:42 .
drwxrwxr-x 3 wil wil 4096 avril 42 20:42 ..
-rw-rw-r-- 1 wil wil XXXX avril 42 20:42 docker-compose.yml
-rw-rw-r-- 1 wil wil XXXX avril 42 20:42 .env
drwxrwxr-x 5 wil wil 4096 avril 42 20:42 requirements
./srcs/requirements:
total XX
drwxrwxr-x 5 wil wil 4096 avril 42 20:42 .
drwxrwxr-x 3 wil wil 4096 avril 42 20:42 ..
drwxrwxr-x 4 wil wil 4096 avril 42 20:42 bonus
drwxrwxr-x 4 wil wil 4096 avril 42 20:42 mariadb
drwxrwxr-x 4 wil wil 4096 avril 42 20:42 nginx
drwxrwxr-x 4 wil wil 4096 avril 42 20:42 tools
drwxrwxr-x 4 wil wil 4096 avril 42 20:42 wordpress
./srcs/requirements/mariadb:
total XX
drwxrwxr-x 4 wil wil 4096 avril 42 20:45 .
drwxrwxr-x 5 wil wil 4096 avril 42 20:42 ..
drwxrwxr-x 2 wil wil 4096 avril 42 20:42 conf
-rw-rw-r-- 1 wil wil XXXX avril 42 20:42 Dockerfile
-rw-rw-r-- 1 wil wil XXXX avril 42 20:42 .dockerignore
drwxrwxr-x 2 wil wil 4096 avril 42 20:42 tools
[...]
./srcs/requirements/nginx:
total XX
drwxrwxr-x 4 wil wil 4096 avril 42 20:42 .
drwxrwxr-x 5 wil wil 4096 avril 42 20:42 ..
drwxrwxr-x 2 wil wil 4096 avril 42 20:42 conf
-rw-rw-r-- 1 wil wil XXXX avril 42 20:42 Dockerfile
-rw-rw-r-- 1 wil wil XXXX avril 42 20:42 .dockerignore
drwxrwxr-x 2 wil wil 4096 avril 42 20:42 tools
[...]
$> cat srcs/.env
DOMAIN_NAME=wil.42.fr
# MYSQL SETUP
MYSQL_USER=XXXXXXXXXXXX
[...]
$>
For obvious security reasons, any credentials, API keys, passwords,
etc., must be saved locally in various ways / files and ignored by
git. Publicly stored credentials will lead you directly to a failure
of the project.

You can store your variables (as a domain name) in an environment
variable file like .env
=== ./docs/commands.txt ===
find . -type f -not -path '*/\.*' -not -path '*/data/*' -not -name '*.md' -not -name 'code.txt' \  
                                                -exec sh -c 'echo "=== $1 ==="; cat "$1"; echo ""' _ {} \; > code.txt



docker logs -f nginx 
--> follow the logs of the nginx container live
=== ./secrets/db_password.txt ===
wpverysecretpassword123
=== ./secrets/credentials.txt ===
username=pmolzer
password=pmolzerverysecretpassword123
=== ./secrets/db_root_password.txt ===
rootverysecretpassword123
=== ./srcs/docker-compose.yml ===
version: '3.8'

services:
  nginx:
    container_name: nginx
    build: requirements/nginx
    image: nginx
    pull_policy: never # this means that the images are not pulled from dockerhub
    ports:
      - "443:443" # this means that the container will be accessible on port 443 and the only container that will be accessible on port 443 by the host is the nginx container
    networks:
      - inception
    volumes:
      - wordpress:/var/www/html
    restart: always # this means that the container will be restarted if it crashes
    env_file: .env

  mariadb:
    container_name: mariadb
    build: requirements/mariadb
    image: mariadb
    pull_policy: never
    networks:
      - inception
    volumes:
      - mariadb:/var/lib/mysql
    restart: always
    env_file: .env
    secrets:
      - db_root_password
      - db_password

  wordpress:
    container_name: wordpress
    build: requirements/wordpress
    image: wordpress
    pull_policy: never
    networks:
      - inception
    volumes:
      - wordpress:/var/www/html
    restart: always
    env_file: .env
    depends_on:
      - mariadb
    secrets:
      - db_password
      - credentials

networks: # the network is used to connect the containers
  inception:
    driver: bridge # the bridge driver is used to connect the containers, diver: bridge means that the containers will be connected to the bridge network
    # bridge network is the default network driver for Docker

volumes:
  mariadb:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/pmolzer/data/mariadb

  wordpress:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/pmolzer/data/wordpress

secrets:
  db_root_password:
    file: ../secrets/db_root_password.txt # Verified: ensure this path is correct relative to compose file
  db_password:
    file: ../secrets/db_password.txt
  credentials:
    file: ../secrets/credentials.txt
=== ./srcs/requirements/mariadb/conf/50-server.cnf ===
#
# These groups are read by MariaDB server.
# Use it for options that only the server (but not clients) should see

# this is read by the standalone daemon and embedded servers
[server]

# this is only for the mysqld standalone daemon
[mysqld]

#
# * Basic Settings
#

user                    = mysql
pid-file                = /run/mysqld/mysqld.pid
basedir                 = /usr
datadir                 = /var/lib/mysql

# Broken reverse DNS slows down connections considerably and name resolve is
# safe to skip if there are no "host by domain name" access grants
skip-name-resolve

# Allow connections from any IP address (required for Docker networking)
bind-address            = 0.0.0.0
port                    = 3306

#
# * Character sets
#

# MySQL/MariaDB default is Latin1, but we rather default to the full
# utf8 4-byte character set.
character-set-server  = utf8mb4
collation-server      = utf8mb4_general_ci

#
# * InnoDB
#

# InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.
# Read the manual for more InnoDB related options. There are many!

# this is only for embedded server
[embedded]

# This group is only read by MariaDB servers, not by MySQL.
# If you use the same .cnf file for MySQL and MariaDB,
# you can put MariaDB-only options here
[mariadb]

=== ./srcs/requirements/mariadb/Dockerfile ===
FROM alpine:3.19

RUN apk update && apk add --no-cache mariadb mariadb-client

# Create the run directory for mysqld
RUN mkdir -p /run/mysqld && chown -R mysql:mysql /run/mysqld

COPY tools/entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh

# Copy custom MariaDB configuration
COPY conf/50-server.cnf /etc/my.cnf.d/50-server.cnf

# EXPOSE is the port that the container will listen on
# it doesn't open the port, it just tells Docker that the container will listen on that port
# and that the port should be mapped to the host
EXPOSE 3306

# ENTRYPOINT is the script that will be executed when the container starts
ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]

# CMD is the command that will be executed when the container starts
CMD ["mysqld", "--user=mysql"] 
=== ./srcs/requirements/mariadb/tools/entrypoint.sh ===
#!/bin/sh

# Check if the database is already initialized
if [ ! -d "/var/lib/mysql/mysql" ]; then
    echo "Initializing database..."
    mysql_install_db --user=mysql --datadir=/var/lib/mysql
    # mariadb needs a temporary server to initialize the database
    # the server is started with the --bootstrap option
    # it will create the database and the user
    # then it will stop

    # mysql_install_db is a script that will create the database and the user

    # Initialize the database
    
    echo "Starting temporary MariaDB server..."
    /usr/bin/mysqld --user=mysql --bootstrap << EOF
USE mysql;
FLUSH PRIVILEGES;

-- Set root password
ALTER USER 'root'@'localhost' IDENTIFIED BY '${MYSQL_ROOT_PASSWORD}';

-- Create database
CREATE DATABASE IF NOT EXISTS ${MYSQL_DATABASE};

-- Create user
CREATE USER IF NOT EXISTS '${MYSQL_USER}'@'%' IDENTIFIED BY '${MYSQL_PASSWORD}';
GRANT ALL PRIVILEGES ON ${MYSQL_DATABASE}.* TO '${MYSQL_USER}'@'%';

-- Flush privileges
FLUSH PRIVILEGES;
EOF
    echo "Database initialized."
fi

echo "Starting MariaDB..."
exec "$@"
=== ./srcs/requirements/mariadb/TESTING.MD ===
# Testing MariaDB

## 1. Verify Database Connection (Terminal)

The database should be accessible from the WordPress container, but not from the host.

**Command:**
```bash
# Check if mariadb is running
docker ps | grep mariadb

# Try to connect from the host (Should FAIL)
mysql -h 127.0.0.1 -P 3306 -u pmolzer -p
# Expected: Connection refused or timeout (since port 3306 is not mapped to host)
```

## 2. Verify Data Persistence (Terminal)

Data should persist even if the container is removed.

**Command:**
```bash
# 1. Create a test table
docker exec -it mariadb mariadb -u root -p$MYSQL_ROOT_PASSWORD -e "USE $MYSQL_DATABASE; CREATE TABLE test_table (id INT); INSERT INTO test_table VALUES (1);"

# 2. Verify data exists
docker exec -it mariadb mariadb -u root -p$MYSQL_ROOT_PASSWORD -e "USE $MYSQL_DATABASE; SELECT * FROM test_table;"
# Expected Output:
# +------+
# | id   |
# +------+
# |    1 |
# +------+

# 3. Remove containers
make down

# 4. Restart containers
make up

# 5. Verify data still exists
docker exec -it mariadb mariadb -u root -p$MYSQL_ROOT_PASSWORD -e "USE $MYSQL_DATABASE; SELECT * FROM test_table;"
# Expected Output: Same as above (id: 1)
```

## 3. Verify User Creation (Terminal)

The initialization script should have created the specific user and database.

**Command:**
```bash
docker exec -it mariadb mariadb -u root -p$MYSQL_ROOT_PASSWORD -e "SELECT User, Host FROM mysql.user;"
```

**Expected Result:**
You should see your custom user (e.g., `pmolzer`) and `root` in the list.

=== ./srcs/requirements/wordpress/conf/custom.ini ===
; Custom PHP configuration for WordPress
; This file overrides default PHP settings for better WordPress performance

[PHP]
; Memory limit - WordPress needs more than the default 128M
memory_limit = 512M

; Maximum execution time for scripts
max_execution_time = 300

; Maximum time for input parsing
max_input_time = 300

; Maximum size of POST data that PHP will accept
post_max_size = 64M

; Maximum allowed size for uploaded files
upload_max_filesize = 64M

; Maximum number of files that can be uploaded at once
max_file_uploads = 20

; Error reporting
display_errors = Off
log_errors = On
error_reporting = E_ALL & ~E_DEPRECATED & ~E_STRICT

=== ./srcs/requirements/wordpress/conf/www.conf ===
; PHP-FPM pool configuration for WordPress
; This file configures the PHP-FPM worker pool

[www]
; Pool name
user = nobody
group = nobody

; Listen on port 9000 (all interfaces) for connections from NGINX
listen = 9000

; Allow connections from any IP (required for Docker networking)
listen.allowed_clients = any

; Process management
pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3

; Timeouts
request_terminate_timeout = 300

; Logging
php_admin_value[error_log] = /var/log/php81/error.log
php_admin_flag[log_errors] = on

=== ./srcs/requirements/wordpress/Dockerfile ===
FROM alpine:3.19

RUN apk update && apk add --no-cache \
    php81 \
    php81-fpm \
    php81-mysqli \
    php81-phar \
    php81-iconv \
    php81-mbstring \
    php81-openssl \
    curl \
    mariadb-client

RUN ln -s /usr/bin/php81 /usr/bin/php

# Install WP-CLI
RUN curl -O https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar && \
    chmod +x wp-cli.phar && \
    mv wp-cli.phar /usr/local/bin/wp

# Copy PHP-FPM and PHP configuration files
COPY conf/www.conf /etc/php81/php-fpm.d/www.conf
COPY conf/custom.ini /etc/php81/conf.d/custom.ini

COPY tools/entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh

WORKDIR /var/www/html

EXPOSE 9000

ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
CMD ["php-fpm81", "-F"]
=== ./srcs/requirements/wordpress/tools/entrypoint.sh ===
#!/bin/sh

# Wait for MariaDB
while ! mariadb -h mariadb -u$MYSQL_USER -p$MYSQL_PASSWORD $MYSQL_DATABASE --silent; do
    echo "Waiting for MariaDB..."
    sleep 2
done

# Download WordPress
if [ ! -f wp-config.php ]; then
    echo "Downloading WordPress..."
    wp core download --allow-root

    echo "Configuring WordPress..."
    wp config create \
        --dbname=$MYSQL_DATABASE \
        --dbuser=$MYSQL_USER \
        --dbpass=$MYSQL_PASSWORD \
        --dbhost=mariadb \
        --allow-root

    echo "Installing WordPress..."
    wp core install \
        --url=$DOMAIN_NAME \
        --title="Inception" \
        --admin_user=$WP_ADMIN_USER \
        --admin_password=$WP_ADMIN_PASSWORD \
        --admin_email=$WP_ADMIN_EMAIL \
        --allow-root

    echo "Creating user..."
    wp user create \
        $WP_USER \
        $WP_USER@example.com \
        --role=author \
        --user_pass=$WP_PASSWORD \
        --allow-root
fi

echo "Starting PHP-FPM..."
exec "$@"
=== ./srcs/requirements/wordpress/TESTING.MD ===
# Testing WordPress

## 1. Verify Installation (Browser)

Navigate to `https://pmolzer.42.fr`.

**Expected Result:**
- You should see the WordPress homepage (not the installation wizard).
- The site title should match what you set in `.env` (e.g., "Inception").

## 2. Verify Admin Login (Browser)

Navigate to `https://pmolzer.42.fr/wp-admin`.

**Credentials:**
- Use the admin username and password from your `.env` file.

**Expected Result:**
- Successful login to the WordPress Dashboard.

## 3. Verify Users (Browser/Terminal)

**Browser:**
- Go to "Users" in the dashboard.
- You should see two users: the administrator and the second user (author/editor).

**Terminal:**
```bash
# List users via WP-CLI
docker exec -it wordpress wp user list --allow-root
```
**Expected Result:**
- A table listing the users, their roles, and emails.

## 4. Verify PHP-FPM (Terminal)

Ensure PHP-FPM is running and handling requests.

**Command:**
```bash
docker logs wordpress
```

**Expected Result:**
- You should see logs indicating PHP-FPM started (e.g., `ready to handle connections`).
- You might see access logs if you've visited the site.

## 5. Verify Database Connection (Terminal)

If the site loads, the database connection is working. If you see "Error establishing a database connection", check the logs.

**Command:**
```bash
docker exec -it wordpress wp db check --allow-root
```

**Expected Result:**
- `Success: The database is available.`

=== ./srcs/requirements/nginx/conf/nginx.conf ===
server {
    listen 443 ssl; # listen on port 443 for HTTPS
    listen [::]:443 ssl; # listen on both IPv4 and IPv6

    server_name pmolzer.42.fr; # server name

    ssl_certificate /etc/nginx/ssl/inception.crt; # path to SSL certificate
    ssl_certificate_key /etc/nginx/ssl/inception.key; # path to SSL private key
    #ssl_protocols TLSv1.2 TLSv1.3; # enable TLSv1.2 and TLSv1.3
    
    ssl_protocols TLSv1.3; # enable TLSv1.3, only one between TLSv1.2 and TLSv1.3 can be enabled in the project
    # TSL is a more secure version of SSL, and more modern
    # TLSv1.3 was published in 2018
    # this enables HTTPS (HTTP over SSL/TLS)
    

    root /var/www/html;
    index index.php index.html;

    #location / {
    #    try_files $uri $uri/ =404;
    #}

    location / {
    try_files $uri $uri/ /index.php?$args;
    }


    location ~ \.php$ { # if the request is for a PHP file
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass wordpress:9000; # pass the request to the PHP-FPM container
        fastcgi_index index.php;
        #include fastcgi_params;
        include /etc/nginx/fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
}
=== ./srcs/requirements/nginx/Dockerfile ===
FROM alpine:3.19

RUN apk update && apk add --no-cache nginx openssl

COPY conf/nginx.conf /etc/nginx/http.d/default.conf
COPY tools/entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh

EXPOSE 443

ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
CMD ["nginx", "-g", "daemon off;"]
=== ./srcs/requirements/nginx/tools/entrypoint.sh ===
#!/bin/sh

# need shebang because alpine doesn't have /bin/bash
# alpine comes with ash by default

# Create SSL directory
mkdir -p /etc/nginx/ssl

# Generate self-signed certificate
# if the certificate doesn't exist, generate it
# we use openssl to generate a self-signed certificate

# A self-signed certificate is a certificate that is not signed 
# by a certificate authority (CA)
# It is used for testing and development purposes
# A certificate authority is a trusted entity that issues digital certificates

# openssl is a tool to generate a self-signed certificate
# -x509: X.509 is a standard for public key infrastructure (PKI)
# -nodes: don't encrypt the private key
# -days: certificate validity period
# -newkey: generate a new private key
# rsa:2048: generate a 2048-bit RSA private key
# -keyout: output the private key
# -out: output the certificate
# -subj: subject of the certificate
if [ ! -f /etc/nginx/ssl/inception.crt ]; then
    echo "Generating SSL certificate..."
    openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
        -keyout /etc/nginx/ssl/inception.key \
        -out /etc/nginx/ssl/inception.crt \
        -subj "/C=FR/ST=IDF/L=Paris/O=42/OU=Inception/CN=pmolzer.42.fr"
fi

# NGINX needs a certificate and a private key to start
# so we copy the certificate and the private key to the NGINX directory
# and then we start NGINX


echo "Starting NGINX..."
exec "$@"
=== ./srcs/requirements/nginx/TESTING.MD ===
# Testing NGINX

## 1. Verify TLS Version (Terminal)

The subject requires TLSv1.2 or TLSv1.3 only.

**Command:**
```bash
# Test TLS 1.2 (Should succeed)
openssl s_client -connect pmolzer.42.fr:443 -tls1_2

# Test TLS 1.3 (Should succeed)
openssl s_client -connect pmolzer.42.fr:443 -tls1_3

# Test TLS 1.0 (Should fail)
openssl s_client -connect pmolzer.42.fr:443 -tls1

# Test TLS 1.1 (Should fail)
openssl s_client -connect pmolzer.42.fr:443 -tls1_1
```

**Expected Result:**
- TLS 1.2/1.3 commands should show the certificate chain and handshake details.
- TLS 1.0/1.1 commands should fail with a handshake error or "no protocols available".

## 2. Verify Port 443 Only (Terminal)

Only port 443 should be exposed to the host.

**Command:**
```bash
docker ps
```

**Expected Result:**
Check the `PORTS` column for the `nginx` container. It should only show `0.0.0.0:443->443/tcp`. It should **not** show port 80.

## 3. Verify Certificate (Browser)

1.  Open `https://pmolzer.42.fr` in your browser.
2.  Click the "Not Secure" or lock icon in the address bar.
3.  View the certificate details.
4.  **Expected Result**:
    - Issued to: `pmolzer.42.fr` (or similar).
    - Issued by: `pmolzer.42.fr` (Self-signed).
    - Protocol: TLS 1.2 or 1.3.

## 4. Verify HTTP Redirect (Optional but good practice)

If you try to access `http://pmolzer.42.fr` (port 80), it should either fail (connection refused) or redirect to HTTPS, depending on your implementation. The subject strictly says "accessible only via port 443", so connection refused on port 80 is the most compliant behavior.

