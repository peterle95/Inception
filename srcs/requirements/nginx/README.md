# NGINX Service

This container provides the NGINX web server with TLS/SSL support, acting as the entry point and reverse proxy for the Inception WordPress infrastructure.

## Table of Contents

- [Overview](#overview)
- [Configuration](#configuration)
- [Dockerfile Breakdown](#dockerfile-breakdown)
- [NGINX Configuration File](#nginx-configuration-file)
- [How It Works](#how-it-works)
- [Integration with Other Services](#integration-with-other-services)
- [SSL/TLS Configuration](#ssltls-configuration)

## Overview

NGINX serves as the **reverse proxy** and **TLS termination point** for the application:
- Accepts **HTTPS** requests on port **443**
- Serves **static files** directly (HTML, CSS, JS, images)
- Proxies **PHP requests** to WordPress via FastCGI
- Provides **TLS/SSL encryption** for all traffic

## Configuration

- **Base Image**: Alpine Linux 3.19
- **Port**: 443 (HTTPS only)
- **TLS Protocols**: TLSv1.2, TLSv1.3
- **Certificate**: Self-signed (generated at startup)
- **Server Name**: `pmolzer.42.fr`

### Environment Variables

- `DOMAIN_NAME` - Server domain name (from `.env`)

## Dockerfile Breakdown

```dockerfile
FROM alpine:3.19
```
- **Base Image**: Alpine Linux 3.19 (minimal, security-focused)
- Benefits: Small size (~7MB), fast startup

```dockerfile
RUN apk update && apk add --no-cache nginx openssl
```
- **Packages**:
  - `nginx` - High-performance web server and reverse proxy
  - `openssl` - For generating self-signed SSL certificates
- **`--no-cache`**: Keeps image size minimal

```dockerfile
COPY conf/nginx.conf /etc/nginx/http.d/default.conf
```
- **Configuration file**: [nginx.conf](file:///\\wsl.localhost\Ubuntu\home\ubuntu\Inception-final\srcs\requirements\nginx\conf\nginx.conf)
- **Location**: `/etc/nginx/http.d/default.conf` (Alpine NGINX config directory)
- **Purpose**: Defines server block, SSL settings, and FastCGI proxy

```dockerfile
COPY tools/entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh
```
- **Entrypoint script**: Generates SSL certificate if needed

```dockerfile
EXPOSE 443
```
- **Port 443**: Standard HTTPS port
- Published to host in `docker-compose.yml`

```dockerfile
ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
CMD ["nginx", "-g", "daemon off;"]
```
- **Entrypoint**: Runs SSL certificate generation
- **CMD**: Starts NGINX in foreground mode (required for Docker)

## NGINX Configuration File

File: [conf/nginx.conf](file:///\\wsl.localhost\Ubuntu\home\ubuntu\Inception-final\srcs\requirements\nginx\conf\nginx.conf)

### Server Block

```nginx
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name pmolzer.42.fr;
```
- **Port 443**: HTTPS port
- **IPv4 and IPv6**: Listen on both protocols
- **SSL**: TLS/SSL enabled
- **Server name**: Domain name for virtual hosting

### SSL/TLS Configuration

```nginx
    ssl_certificate /etc/nginx/ssl/inception.crt;
    ssl_certificate_key /etc/nginx/ssl/inception.key;
    ssl_protocols TLSv1.2 TLSv1.3;
```
- **Certificate**: Self-signed certificate (generated by entrypoint)
- **Private key**: RSA 2048-bit key
- **Protocols**: TLSv1.2 and TLSv1.3 (secure modern protocols)
- **No SSLv3/TLSv1.0/TLSv1.1**: Outdated and insecure

### Document Root

```nginx
    root /var/www/html;
    index index.php index.html;
```
- **Root directory**: Shared volume with WordPress
- **Index files**: Try `index.php` first, then `index.html`

### Static Files and WordPress Routing

```nginx
    location / {
        try_files $uri $uri/ /index.php?$args;
    }
```
- **Static files**: Serve directly if they exist (`$uri`)
- **Directories**: Check if directory exists (`$uri/`)
- **WordPress routing**: Fallback to `index.php` with query args (for permalinks)

### PHP/WordPress FastCGI Proxy

```nginx
    location ~ \.php$ {
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass wordpress:9000;
        fastcgi_index index.php;
        include /etc/nginx/fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
```
- **Pattern**: Matches all `.php` files
- **FastCGI pass**: Proxy to `wordpress:9000` (PHP-FPM)
- **Path info**: Splits script name and path correctly
- **Script filename**: Passes absolute path to PHP-FPM
- **FastCGI params**: Standard FastCGI environment variables

## How It Works

### Startup Sequence

1. **Container starts** → `entrypoint.sh` executed
2. **Create SSL directory** → `/etc/nginx/ssl`
3. **Check for certificate**:
   - If missing → Generate self-signed certificate
   - If exists → Skip generation
4. **Start NGINX** → `nginx -g "daemon off;"`
5. **Listen on port 443** → Accept HTTPS connections

### Request Flow

```
User Browser (HTTPS/443)
    ↓ TLS Handshake
NGINX (TLS Termination)
    ↓ Decrypt
┌─────────────────────────┐
│ Static file? (CSS/JS)   │ → Serve directly
└─────────────────────────┘
    ↓ No, .php file
FastCGI Protocol
    ↓
WordPress PHP-FPM (9000)
    ↓
Execute PHP / Query MariaDB
    ↓
Return HTML
    ↓
NGINX
    ↓ TLS Encrypt
User Browser
```

## Integration with Other Services

### WordPress Connection

NGINX forwards PHP requests to WordPress via **FastCGI**:

```nginx
fastcgi_pass wordpress:9000;
```

- **DNS**: Docker resolves `wordpress` to container IP
- **Port 9000**: PHP-FPM listening port
- **Protocol**: FastCGI (binary protocol for PHP)

### Shared Volume

Both NGINX and WordPress share `/var/www/html`:

```yaml
# In docker-compose.yml
volumes:
  - wordpress:/var/www/html
```

- **NGINX**: Reads static files (CSS, JS, images)
- **WordPress**: Writes WordPress core and uploads
- **Shared**: Both containers access the same files

### Network Flow Example

1. **User visits** `https://pmolzer.42.fr/`
2. **NGINX receives HTTPS** request on port 443
3. **TLS handshake** → Decrypt request
4. **Check for static file** → `/var/www/html/index.php` (not static)
5. **Proxy to PHP-FPM** → `fastcgi_pass wordpress:9000`
6. **WordPress executes** PHP → Queries MariaDB
7. **WordPress returns** HTML to NGINX
8. **NGINX encrypts** response with TLS
9. **User receives** HTTPS response

## SSL/TLS Configuration

### Certificate Generation

The entrypoint script generates a **self-signed certificate**:

```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    -keyout /etc/nginx/ssl/inception.key \
    -out /etc/nginx/ssl/inception.crt \
    -subj "/C=FR/ST=IDF/L=Paris/O=42/OU=Inception/CN=pmolzer.42.fr"
```

- **`-x509`**: Self-signed certificate (not from CA)
- **`-nodes`**: No passphrase on private key
- **`-days 365`**: Valid for 1 year
- **`-newkey rsa:2048`**: Generate 2048-bit RSA key
- **Subject**: Certificate identity information

### Security Considerations

⚠️ **Self-signed certificate**:
- Not trusted by browsers (security warning)
- Suitable for development/testing
- For production: Use Let's Encrypt or proper CA

✅ **TLS protocols**:
- TLSv1.2 and TLSv1.3 only
- No outdated/insecure protocols

### Production Recommendations

For production deployment:
1. Use **Let's Encrypt** with Certbot
2. Implement **HTTP to HTTPS redirect**
3. Add **HSTS headers** (HTTP Strict Transport Security)
4. Configure **stronger cipher suites**
5. Enable **OCSP stapling**

---

**Related Documentation**:
- [Main Project README](file:///\\wsl.localhost\\Ubuntu\\home\\ubuntu\\Inception-final\\README.md)
- [NGINX Testing Guide](file:///\\wsl.localhost\\Ubuntu\\home\\ubuntu\\Inception-final\\srcs\\requirements\\nginx\\TESTING.MD)
- [WordPress Service README](file:///\\wsl.localhost\\Ubuntu\\home\\ubuntu\\Inception-final\\srcs\\requirements\\wordpress\\README.md)
- [MariaDB Service README](file:///\\wsl.localhost\\Ubuntu\\home\\ubuntu\\Inception-final\\srcs\\requirements\\mariadb\\README.md)